动态规划的题目就是这么蛋疼，有时候绞尽脑汁就是想不出来。。。一看人家的思路。。。哦。。原来这么简单。。。代码原来这么短。。

 - n==0: 只有一种情况，那就是不染色，return 1;
 - n==1: k种颜色，所以k中情况,return k;
 - n>=2:
    - dp[i][0]表示到第i个的时候，第i个和第i-1个颜色相同的情况数
    - dp[i][1]表示到第i个的时候，第i个和第i-1个颜色不同的情况数

    于是，有如下递推公式：
        
        dp[i][0] = dp[i-1][1];
        dp[i][1] = (dp[i-1][0]+dp[i-1][1])*(k-1);
    
    初始化`dp[1][0] = k`, `dp[1][1] = k*(k-1)`，最后`dp[n-1][0]+dp[n-1][1]`即为所求(下标从0开始)。
    
    但是这样做出来会超内存，再仔细看一下上面的递推公式，发现其实并不需要开两个数组，用两个变量就可以了，于是变成了这样：
    
        初始化 d1 = k, d2 = k*(k-1);
        递推：
            tmp = d1;
            d1 = d2;
            d2 = (tmp+d2)*(k-1);
            
        最后，d1+d2即为结果。
        
